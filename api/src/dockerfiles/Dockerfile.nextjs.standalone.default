# Suggested Filename: Dockerfile.nextjs.standalone.default
# (Original filename provided: api/src/dockerfiles/Dockerfile.nextjs.default)

# Stage 1: Install dependencies
# Use a specific LTS Node.js version on Alpine for a small base
FROM node:18-alpine AS deps
WORKDIR /app

# Enable corepack for managing pnpm/yarn versions (available in Node 18)
# This ensures the correct package manager version is used if specified in package.json
RUN corepack enable

# Copy package manager files first to leverage Docker cache
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./

# Install dependencies based on the lock file present
# Corepack will use the pnpm/yarn version defined in package.json if available,
# otherwise, it will use its default or a globally installed one.
RUN \
    if [ -f yarn.lock ]; then \
        echo "--- Installing dependencies with Yarn ---"; \
        yarn install --frozen-lockfile; \
    elif [ -f package-lock.json ]; then \
        echo "--- Installing dependencies with npm ---"; \
        npm ci; \
    elif [ -f pnpm-lock.yaml ]; then \
        echo "--- Installing dependencies with pnpm (via corepack) ---"; \
        # Corepack should automatically pick up pnpm. If not, `corepack prepare pnpm@latest --activate` can be used.
        pnpm install --frozen-lockfile; \
    else \
        echo "Error: Lockfile (yarn.lock, package-lock.json, or pnpm-lock.yaml) not found." && \
        echo "Please commit a lockfile to ensure reproducible builds." && \
        exit 1; \
    fi

# ---

# Stage 2: Build the Next.js application
FROM node:18-alpine AS builder
WORKDIR /app

# Again, enable corepack if build scripts rely on specific package manager versions
RUN corepack enable

# Copy dependencies from the 'deps' stage (cached layer)
COPY --from=deps /app/node_modules ./node_modules
# Copy the rest of the application code
# Consider using a .dockerignore file to exclude unnecessary files (.git, .vscode, etc.)
COPY . .

# Set build-time arguments if needed by Next.js build (e.g., NEXT_PUBLIC_...)
# ARG NEXT_PUBLIC_API_URL
# ENV NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL

# Build the Next.js application
# This assumes package.json has a "build" script (e.g., "build": "next build")
RUN \
    echo "--- Building Next.js application ---"; \
    if [ -f yarn.lock ]; then \
        echo "Running 'yarn run build'"; \
        yarn run build; \
    elif [ -f pnpm-lock.yaml ]; then \
        echo "Running 'pnpm run build'"; \
        pnpm run build; \
    elif [ -f package-lock.json ]; then \
        echo "Running 'npm run build'"; \
        npm run build; \
    else \
        echo "Error: Could not determine package manager to run build. No lockfile found." && \
        echo "This stage expects dependencies to be installed and a build script available." && \
        exit 1; \
    fi
# ---

# Stage 3: Production image using standalone output
# This stage relies on 'output: "standalone"' in your next.config.js
FROM node:18-alpine AS runner
WORKDIR /app

ENV NODE_ENV=production
# HOSTNAME=0.0.0.0 allows the Next.js server to accept connections on all network interfaces.
ENV HOSTNAME="0.0.0.0"
# Default port, can be overridden by the PORT environment variable at runtime.
ENV PORT=3000

# Create a non-root user and group for better security.
# Using GID/UID 1001 is a common practice.
RUN addgroup -S -g 1001 appgroup && \
    adduser -S -u 1001 appuser -G appgroup

# Copy necessary files from the builder stage for the standalone application.
# The --chown flag sets the ownership of the copied files to the non-root user.

# Copy public assets
COPY --from=builder /app/public ./public

# Copy the standalone server output.
# The contents of /app/.next/standalone (from builder) are copied into ./ (which is /app in runner).
# This means server.js will be at /app/server.js.
COPY --from=builder --chown=appuser:appgroup /app/.next/standalone ./

# Copy static assets generated by Next.js.
COPY --from=builder --chown=appuser:appgroup /app/.next/static ./.next/static

# Copy next.config.js (or .mjs) if it's needed for runtime configuration.
# The wildcard handles both .js and .mjs extensions.
COPY --from=builder --chown=appuser:appgroup /app/next.config.* ./

# Switch to the non-root user.
USER appuser

# Expose the port the app runs on.
EXPOSE 3000

# Healthcheck (optional, but recommended)
# Adjust the path and command if your server.js has a specific health endpoint or startup time.
# HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
#   CMD curl -f http://localhost:3000/ || exit 1
# (If using curl, you might need to add `apk add --no-cache curl` in the runner stage if not already present from base)
# For Node.js apps, a simpler check might be `CMD [ "node", "-e", "require